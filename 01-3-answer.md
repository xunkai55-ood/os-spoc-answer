# 01-3 Spoc Answer

2012011486 张洵恺

2012013290 韩珊

## 分析和实验funcall.c

#### 修改代码，可正常显示小组两位同学的学号（用字符串），生成funcall.c的汇编码，理解其实现并给汇编码写注释，尝试用xem的简单调试功能单步调试代码

c代码见 [funcall.c](01-3-answer/funcall.c)

汇编代码与注释见 [funcall.s](01-3-answer/funcall.s)

#### funcall中的堆栈有多大？是内核态堆栈还是用户态堆栈

使用xem进行调试，显示寄存器，可以看到user位为0，是内核态；tsp为0x10038，current sp为0x7c00000，则整个的栈大小约是124MB

#### funcall中的全局变量ret放在内存中何处？如何对它寻址？

观看代码，针对c文件中第13行`ret = 1`进行调试，其汇编代码在0x18处，汇编文件中0x18~0x1b为0x00000045，运行时却是0x00008c45。因此45为SG（将寄存器a中的值存入全局内存）的代码，8c是此时的偏移量，根据CPU的文档得知目标内存为0x8c+0x1c（PC先后移了）=0xa8。

程序中是使用SG命令，pc+偏移量全局寻址的。

#### funcall中的字符串放在内存中何处？如何对它寻址？

看汇编文件中90~94行分析，PSHI压入立即数22，LEAG、PSHA压入了字符串地址，因此单步调试此处进行分析。

单步调试时，此处代码从0x00000008变为0x00001c08，故认为1c是LEAG命令的操作数，此时pc是0x74，总和为0x90，用x命令验证此处确实是字符串"2012011486 2012013290"字符串的开始处。

程序中是使用LEAG命令，也是pc+偏移量寻址的。

#### 局部变量i在内存中的何处？如何对它寻址？

看汇编代码60~61行（对应`i = n`），是LL和SL语句，前者从变量n读到寄存器a，后者从寄存器a写入内存（注意LL和SL是local address，这是因为函数中所有变量都在函数对应的栈片段之中）。

此处SL对应的机器码为0x440，参数为4，也即是在此时sp+4的位置。

#### 当前系统是处于中断使能状态吗？

使用i指令，看到iena为0，中断使能是失效的。

#### funcall中的函数参数是如何传递的？函数返回值是如何传递的？

参数传递：各参数从后往前依次压入栈中。

返回值传递：返回值放在寄存器a中。

#### 分析并说明funcall执行文件的格式和内容 　

+ 00000000~00000003: Magic Number 0xC0DEF00D
+ 00000004~00000007: bss
+ 00000008~0000000b: entry
+ 0000000c~0000000f: flags
+ 00000010~0000009c: codes
+ 000000a0~000000b4: string literal

